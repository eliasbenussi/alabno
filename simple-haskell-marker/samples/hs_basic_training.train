ok	module Sequences where\n\n
ok	import Data.Char (ord, chr)\n\n
ok	maxOf2 :: Int -> Int -> Int\n-- Returns first argument if it is larger than the second,\n-- the second argument otherwise\nmaxOf2 x y\n  | x > y     = x\n
ok	  | otherwise = y\n\n
ok	maxOf3 :: Int -> Int -> Int -> Int\n-- Returns the largest of three Ints\nmaxOf3 x y z\n  = maxOf2 x (maxOf2 y z)\n\n
comment	-- Alternative version of maxOf3 using >= and &&\nmaxof3' x y z\n  = if x >= y && x >= z\n    then x\n    else if y >= x && y >= z\n
ok	         then y\n         else z\n\n
comment	-- Another version of maxOf3 using just >=\nmaxof3'' x y z\n  = if x >= y\n    then if x >= z\n         then x\n
ok	         else z\n    else if y >= z\n         then y\n         else z\n\n
ok	isADigit :: Char -> Bool\n-- Returns True if the character represents a digit '0'..'9';\n-- False otherwise\nisADigit c\n  = c >= '0' && c <= '9'\n\n
comment	-- False otherwise\n
ok	isAlpha :: Char -> Bool\n-- Returns True if the character represents an alphabetic\n-- character either in the range 'a'..'z' or in the range 'A'..'Z';\nisAlpha c\n  = (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n\n
ok	digitToInt :: Char -> Int\n-- Pre: the character is one of '0'..'9'\n-- Returns the integer [0..9] corresponding to the given character.\n-- Note: this is a simpler version of digitToInt in module Data.Char,\n-- which does not assume the precondition.\n
ok	digitToInt c\n  = ord c - ord '0'\n\n
ok	toUpper :: Char -> Char\n-- Returns the upper case character corresponding to the input.\n-- Uses guards by way of variety.\ntoUpper c\n  | c >= 'A' && c <= 'Z' = c\n
ok	  | c >= 'a' && c <= 'z' = chr (ord 'A' + ord c - ord 'a')\n\n
comment	--\n-- Sequences and series\n--\n\n
comment	-- Arithmetic sequence\n
ok	arithmeticSeq :: Double -> Double -> Int -> Double\narithmeticSeq a d n\n  = a + fromIntegral n * d\n\n
comment	-- Geometric sequence\n
ok	geometricSeq :: Double -> Double -> Int -> Double\ngeometricSeq a r n\n  = a * r ^ n\n\n
comment	-- Arithmetic series\n
ok	arithmeticSeries :: Double -> Double -> Int -> Double\narithmeticSeries a d n\n  = (n' + 1) * (a + d * n' / 2)\n  where\n    n' = fromIntegral n\n\n
comment	-- Geometric series\n
ok	geometricSeries :: Double -> Double -> Int -> Double\ngeometricSeries a r n\n  | r == 1    = (fromIntegral n + 1) * a\n  | otherwise = a * (1 - r ^ (n + 1)) / (1 - r)\n
ok	module MP where\n\n
ok	import System.Environment\n\n
ok	type FileContents = String\n\n
ok	type Keyword      = String\ntype KeywordValue = String\ntype KeywordDefs  = [(Keyword, KeywordValue)]\n\n
ok	separators :: String\nseparators\n  = " \n\t.,:;!\"\'()<>/\\"\n\n\n
unimplemented	lookUp :: String -> [(String, a)] -> [a]\nlookUp = error "TODO: implement lookUp"\n\n
indentation	split :: [Char] -> String -> (String, [String])\nsplit chs []\n    = ("", [""])\nsplit chs (c : cs)\n        | elem c chs = (c : terms, "" : words)\n        | otherwise = (terms, (c:w) : ws)\n        where\n                (terms, words) = split chs cs\n                (w : ws) = words\n\n
unimplemented	combine :: String -> [String] -> [String]\ncombine = error "TODO: implement combine"\n\n
unimplemented	getKeywordDefs :: [String] -> KeywordDefs\ngetKeywordDefs = error "TODO: implement getKeywordDefs"\n\n
unimplemented	expand :: FileContents -> FileContents -> FileContents\nexpand = error "TODO: implement expand"\n\n
ok	-- You may wish to uncomment and implement this helper function\n-- when implementing expand\n
ok	-- replaceWord :: String -> KeywordDefs -> String\n\n\n\n
ok	main :: IO ()\n-- The provided main program which uses your functions to merge a\n-- template and source file.\nmain = do\n  args <- getArgs\n  main' args\n\n
ok	  where\n
ok	    main' :: [String] -> IO ()\n    main' [template, source, output] = do\n      t <- readFile template\n      i <- readFile source\n      writeFile output (expand t i)\n    main' _ = putStrLn ("Usage: runghc MP <template> <info> <output>")\n\n
ok	maxOf2 :: Int -> Int -> Int\n-- Returns first argument if it is larger than the second,\n-- the second argument otherwise\nmaxOf2 x y\n  | x > y     = x\n  | otherwise = y\n  \n
whitespace	maxOf2 :: Int -> Int -> Int\n-- Returns first argument if it is larger than the second,\n-- the second argument otherwise\nmaxOf2 x y\n  | x>y = x\n  | otherwise = y\n  \n
whitespace	maxOf2 :: Int -> Int -> Int\n-- Returns first argument if it is larger than the second,\n-- the second argument otherwise\nmaxOf2 x y\n  | x>y = x\n  | otherwise= y\n\n
ok	maxOf3 :: Int -> Int -> Int -> Int\n-- Returns the largest of three Ints\nmaxOf3 x y z\n  = maxOf2 x (maxOf2 y z)\n  \n
reuse	maxOf3 :: Int -> Int -> Int -> Int\n-- Returns the largest of three Ints\nmaxOf3 x y z = if maxOf2 x y == x && maxOf2 x z == x then x else maxOf2 y z\n\n
reuse	maxOf3 :: Int -> Int -> Int -> Int\n-- Returns the largest of three Ints\nmaxOf3 x y z \n  = if maxOf2 x y == x && maxOf2 x z == x then x else maxOf2 y z\n\n
ok	isADigit :: Char -> Bool\n-- Returns True if the character represents a digit '0'..'9';\n-- False otherwise\nisADigit c\n  = c >= '0' && c <= '9'\n  \n
minustenk	isADigit :: Char -> Bool\n-- Returns True if the character represents a digit '0'..'9';\n-- False otherwise\nisADigit c\n  | c >= '0' && c <= '9' = True\n  | otherwise            = False\n  \n
conversion	isADigit :: Char -> Bool\n-- Returns True if the character represents a digit '0'..'9';\n-- False otherwise\nisADigit c\n  = ord c >= ord '0' && ord c <= ord '9'\n  \n
minustenk	isADigit :: Char -> Bool\n-- Returns True if the character represents a digit '0'..'9';\n-- False otherwise\nisADigit c\n  | ord c >= ord '0' && ord c <= ord '9' = True\n  | otherwise = False\n\n
comment	-- False otherwise\n
ok	isAlpha :: Char -> Bool\n-- Returns True if the character represents an alphabetic\n-- character either in the range 'a'..'z' or in the range 'A'..'Z';\nisAlpha c\n  = (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n  \n
comment	-- False otherwise\n
minustenk	isAlpha :: Char -> Bool\n-- Returns True if the character represents an alphabetic\n-- character either in the range 'a'..'z' or in the range 'A'..'Z';\nisAlpha c\n  | (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') = True\n  | otherwise = False\n  \n
comment	-- False otherwise\n
conversion	isAlpha :: Char -> Bool\n-- Returns True if the character represents an alphabetic\n-- character either in the range 'a'..'z' or in the range 'A'..'Z';\nisAlpha c\n  = (ord c >= ord 'a' && ord c <= ord 'z') || (ord c >= ord 'A' && ord c <= ord 'Z')\n  \n
comment	-- False otherwise\n
minustenk	isAlpha :: Char -> Bool\n-- Returns True if the character represents an alphabetic\n-- character either in the range 'a'..'z' or in the range 'A'..'Z';\nisAlpha c\n  | (ord c >= ord 'a' && ord c <= ord 'z') || (ord c >= ord 'A' && ord c <= ord 'Z') = True\n  | otherwise = False\n\n
ok	digitToInt :: Char -> Int\n-- Pre: the character is one of '0'..'9'\n-- Returns the integer [0..9] corresponding to the given character.\n-- Note: this is a simpler version of digitToInt in module Data.Char,\n-- which does not assume the precondition.\ndigitToInt c\n  = ord c - ord '0'\n  \n
magic	digitToInt :: Char -> Int\n-- Pre: the character is one of '0'..'9'\n-- Returns the integer [0..9] corresponding to the given character.\n-- Note: this is a simpler version of digitToInt in module Data.Char,\n-- which does not assume the precondition.\ndigitToInt c\n  = ord c - 48\n\n
ok	toUpper :: Char -> Char\n-- Returns the upper case character corresponding to the input.\n-- Uses guards by way of variety.\ntoUpper c\n  | c >= 'A' && c <= 'Z' = c\n  | c >= 'a' && c <= 'z' = chr (ord 'A' + ord c - ord 'a')\n\n
ok	--\n-- Sequences and series\n--\n\n
comment	-- Arithmetic sequence\n
ok	arithmeticSeq :: Double -> Double -> Int -> Double\narithmeticSeq a d n\n  = a + fromIntegral n * d\n\n
comment	-- Geometric sequence\n
ok	geometricSeq :: Double -> Double -> Int -> Double\ngeometricSeq a r n\n  = a * r ^ n\n\n
comment	-- Arithmetic series\n
ok	arithmeticSeries :: Double -> Double -> Int -> Double\narithmeticSeries a d n\n  = (n' + 1) * (a + d * n' / 2)\n  where\n    n' = fromIntegral n\n\n
comment	-- Geometric series\n
ok	geometricSeries :: Double -> Double -> Int -> Double\ngeometricSeries a r n\n  | r == 1    = (fromIntegral n + 1) * a\n  | otherwise = a * (1 - r ^ (n + 1)) / (1 - r)\n
ok	foo :: int -> int -> int\nfoo a _\n= 2 * a\n\n
ok	foo :: int -> int\nfoo a\n= 2 * a\n\n
ok	lookupChar :: Char -> Rules -> String\nlookupChar c rules\n  = head [s | (ch, s) <- rules, ch == c]\n\n
ok	expandOne :: Rules -> String -> String\nexpandOne r s\n  = concat (map (flip lookupChar r) s)\n\n
ok	expand :: Rules -> String -> Int -> String\nexpand r s n\n  = s\n\n
ok	expand :: Rules -> String -> Int -> String\nexpand r s n\n  = iterate (expandOne r) s !! n\n\n
ok	move :: Char -> TurtleState -> Float -> TurtleState\nmove ’L’ (position, angle) turn\n  = (position, angle + turn)\nmove ’R’ (position, angle) turn\n  = (position, angle - turn)\nmove ’F’ ((x, y), angle) turn\n  = ((x + cos (degreesToRadians angle),\n  y + sin (degreesToRadians angle)), angle)\n\n
ok	degreesToRadians :: Float -> Float\ndegreesToRadians x\n  = (x / 180) * pi\n\n
ok	trace1 :: String -> Float -> Colour -> [ColouredLine]\ntrace1 cs angle colour\n  = lines\n  where\n    (lines, nullString) = trace’ cs ((0,0), 90)\n\n
ok	trace’ :: [int] -> [int]\ntrace’ [] t\n  = ([], [])\n\n
ok	trace' :: [int] -> [int]\ntrace’ (c : cs) t\n  | c == ’F’ = ((p, p’, colour) : lines’, cs’)\n  | c == ’[’ = (lines’’ ++ lines’’’, cs’’’)\n  | c == ’]’ = ([], cs)\n  | otherwise = (lines’, cs’)\n  where\n    (p’, a’) = move c t angle\n    (lines’, cs’) = trace’ cs (p’, a’)\n    (lines’’, cs’’) = trace’ cs t\n    (lines’’’, cs’’’) = trace’ cs’’ t\n
ok	    (p, a) = t\n\n
ok	trace2 :: String -> Float -> Colour -> [ColouredLine]\ntrace2 cs turn colour\n  = trace’ cs ((0, 0), 90) []\n\n
ok	trace’ :: String -> TurtleState -> Stack -> [ColouredLine]\ntrace’ [] _ _\n  = []\ntrace’ (’F’ : cs) ts@(position, angle) stack\n  = (position, newPosition, colour) :\n      trace’ cs (newPosition, newAngle) stack\n    where\n      (newPosition, newAngle) = move ’F’ ts turn\n\n
ok	trace’ :: String -> TurtleState -> Stack -> [ColouredLine]\ntrace’ (’[’ : cs) ts stack\n  = trace’ cs ts (ts : stack)\ntrace’ (’]’ : cs) _ (ts : stack)\n  = trace’ cs ts stack\ntrace’ (c : cs) ts stack\n  = trace’ cs (move c ts turn) stack\n\n
signature	foo :: int -> int -> int\nfoo a\n= 2 * a\n\n
signature	bar :: (int, int) -> int\nbar a\n= a\n\n
signature	lookupChar :: Char -> Rules -> String\nlookupChar c\n  = head [s | (ch, s) <- rules, ch == c]\n\n
signature	lookupChar :: Char -> Rules -> String\nlookupChar c rules\n  = rules\n\n
signature	lookupChar :: Char -> Rules -> String\nlookupChar c rules\n  = c\n\n
signature	lookupChar :: Char -> String\nlookupChar c rules\n  = head [s | (ch, s) <- rules, ch == c]\n\n
signature	expandOne :: Rules -> String -> String\nexpandOne r s\n  = concat (map (flip lookupChar r) s)\n\n
signature	expand :: Rules -> Int -> String\nexpand r s n\n  = iterate (expandOne r) s !! n\n\n
signature	expand :: Rules -> String -> Int -> String\nexpand r s\n  = iterate (expandOne r) s !! n\n\n
signature	expand :: Rules -> String -> Int -> String\nexpand r s n\n  = n\n\n
signature	expand :: Rules -> String -> Int -> String\nexpand r s n\n  = r\n\n
signature	move :: Char -> TurtleState -> Float -> TurtleState\nmove ’L’ turn\n  = (position, angle + turn)\nmove ’R’ (position, angle) turn\n  = (position, angle - turn)\nmove ’F’ ((x, y), angle) turn\n  = ((x + cos (degreesToRadians angle),\n  y + sin (degreesToRadians angle)), angle)\n\n
signature	move :: Char -> TurtleState -> Float -> TurtleState\nmove ’L’ (position, angle) turn\n  = (position, angle + turn)\nmove (position, angle) turn\n  = (position, angle - turn)\nmove ’F’ ((x, y), angle) turn\n  = ((x + cos (degreesToRadians angle),\n  y + sin (degreesToRadians angle)), angle)\n\n
signature	move :: Char -> TurtleState -> Float -> TurtleState\nmove ’L’ (position, angle) turn\n  = (position, angle + turn)\nmove ’R’ (position, angle) turn\n  = (position, angle - turn)\nmove ’F’ ((x, y), angle)\n  = ((x + cos (degreesToRadians angle),\n  y + sin (degreesToRadians angle)), angle)\n\n
signature	move :: Char -> Float -> TurtleState\nmove ’L’ (position, angle) turn\n  = (position, angle + turn)\nmove ’R’ (position, angle) turn\n  = (position, angle - turn)\nmove ’F’ ((x, y), angle) turn\n  = ((x + cos (degreesToRadians angle),\n  y + sin (degreesToRadians angle)), angle)\n\n
signature	move :: Char -> TurtleState -> TurtleState\nmove ’L’ (position, angle) turn\n  = (position, angle + turn)\nmove ’R’ (position, angle) turn\n  = (position, angle - turn)\nmove ’F’ ((x, y), angle) turn\n  = ((x + cos (degreesToRadians angle),\n  y + sin (degreesToRadians angle)), angle)\n\n
signature	degreesToRadians :: Float -> Float\ndegreesToRadians\n  = (x / 180) * pi\n\n
signature	degreesToRadians :: Float\ndegreesToRadians x\n  = (x / 180) * pi\n\n
signature	degreesToRadians :: Float -> Float\ndegreesToRadians x u\n  = (x / 180) * pi\n\n
signature	trace1 :: Float -> Colour -> [ColouredLine]\ntrace1 cs angle colour\n  = lines\n  where\n    (lines, nullString) = trace’ cs ((0,0), 90)\n\n
signature	trace1 :: String -> Float -> [ColouredLine]\ntrace1 cs angle colour\n  = lines\n  where\n    (lines, nullString) = trace’ cs ((0,0), 90)\n\n
signature	trace1 :: String -> Float -> Colour -> [ColouredLine]\ntrace1 cs angle\n  = lines\n  where\n    (lines, nullString) = trace’ cs ((0,0), 90)\n\n
signature	trace1 :: String -> Float -> Colour -> [ColouredLine]\ntrace1 cs colour\n  = lines\n  where\n    (lines, nullString) = trace’ cs ((0,0), 90)\n\n
signature	trace1 :: String -> Float -> Colour -> [ColouredLine]\ntrace1 angle colour\n  = lines\n  where\n    (lines, nullString) = trace’ cs ((0,0), 90)\n\n
signature	trace’ :: [int]\ntrace’ [] t\n  = ([], [])\n\n
signature	;\n
signature	trace’ :: [int] -> [int]\ntrace’ []\n  = ([], [])\n\n
signature	;\n
signature	trace’ :: [int] -> [int]\ntrace’ t\n  = ([], [])\n\n
signature	trace' :: [int]\ntrace’ (c : cs) t\n  | c == ’F’ = ((p, p’, colour) : lines’, cs’)\n  | c == ’[’ = (lines’’ ++ lines’’’, cs’’’)\n  | c == ’]’ = ([], cs)\n  | otherwise = (lines’, cs’)\n  where\n    (p’, a’) = move c t angle\n    (lines’, cs’) = trace’ cs (p’, a’)\n    (lines’’, cs’’) = trace’ cs t\n    (lines’’’, cs’’’) = trace’ cs’’ t\n
signature	    (p, a) = t\n\n
signature	trace' :: [int] -> [int]\ntrace’ t\n  | c == ’F’ = ((p, p’, colour) : lines’, cs’)\n  | c == ’[’ = (lines’’ ++ lines’’’, cs’’’)\n  | c == ’]’ = ([], cs)\n  | otherwise = (lines’, cs’)\n  where\n    (p’, a’) = move c t angle\n    (lines’, cs’) = trace’ cs (p’, a’)\n    (lines’’, cs’’) = trace’ cs t\n    (lines’’’, cs’’’) = trace’ cs’’ t\n
signature	    (p, a) = t\n\n
signature	trace' :: [int] -> [int]\ntrace’ (c : cs)\n  | c == ’F’ = ((p, p’, colour) : lines’, cs’)\n  | c == ’[’ = (lines’’ ++ lines’’’, cs’’’)\n  | c == ’]’ = ([], cs)\n  | otherwise = (lines’, cs’)\n  where\n    (p’, a’) = move c t angle\n    (lines’, cs’) = trace’ cs (p’, a’)\n    (lines’’, cs’’) = trace’ cs t\n    (lines’’’, cs’’’) = trace’ cs’’ t\n
signature	    (p, a) = t\n\n
signature	trace2 :: String -> Float -> [ColouredLine]\ntrace2 cs turn colour\n  = trace’ cs ((0, 0), 90) []\n\n\n
signature	trace2 :: String -> Colour -> [ColouredLine]\ntrace2 cs turn colour\n  = trace’ cs ((0, 0), 90) []\n\n\n
signature	trace2 :: Float -> Colour -> [ColouredLine]\ntrace2 cs turn colour\n  = trace’ cs ((0, 0), 90) []\n\n\n
signature	trace2 :: String -> Float -> Colour\ntrace2 cs turn colour\n  = trace’ cs ((0, 0), 90) []\n\n
signature	trace2 :: String -> Float -> Colour -> [ColouredLine]\ntrace2 turn colour\n  = trace’ cs ((0, 0), 90) []\n\n
signature	trace2 :: String -> Float -> Colour -> [ColouredLine]\ntrace2 cs colour\n  = trace’ cs ((0, 0), 90) []\n\n
signature	trace2 :: String -> Float -> Colour -> [ColouredLine]\ntrace2 cs turn\n  = trace’ cs ((0, 0), 90) []\n\n
signature	trace’ :: TurtleState -> Stack -> [ColouredLine]\ntrace’ [] _ _\n  = []\ntrace’ (’F’ : cs) ts@(position, angle) stack\n  = (position, newPosition, colour) :\n      trace’ cs (newPosition, newAngle) stack\n    where\n      (newPosition, newAngle) = move ’F’ ts turn\n\n
signature	trace’ :: String -> Stack -> [ColouredLine]\ntrace’ [] _ _\n  = []\ntrace’ (’F’ : cs) ts@(position, angle) stack\n  = (position, newPosition, colour) :\n      trace’ cs (newPosition, newAngle) stack\n    where\n      (newPosition, newAngle) = move ’F’ ts turn\n\n
signature	trace’ :: String -> TurtleState -> [ColouredLine]\ntrace’ [] _ _\n  = []\ntrace’ (’F’ : cs) ts@(position, angle) stack\n  = (position, newPosition, colour) :\n      trace’ cs (newPosition, newAngle) stack\n    where\n      (newPosition, newAngle) = move ’F’ ts turn\n\n
signature	trace’ :: String -> Stack\ntrace’ [] _ _\n  = []\ntrace’ (’F’ : cs) ts@(position, angle) stack\n  = (position, newPosition, colour) :\n      trace’ cs (newPosition, newAngle) stack\n    where\n      (newPosition, newAngle) = move ’F’ ts turn\n\n
signature	trace’ :: String -> TurtleState -> Stack -> [ColouredLine]\ntrace’ []\n  = []\ntrace’ (’F’ : cs) ts@(position, angle) stack\n  = (position, newPosition, colour) :\n      trace’ cs (newPosition, newAngle) stack\n    where\n      (newPosition, newAngle) = move ’F’ ts turn\n\n
signature	trace’ :: String -> TurtleState -> Stack -> [ColouredLine]\ntrace’ [] _ _\n  = []\ntrace’ (’F’ : cs) stack\n  = (position, newPosition, colour) :\n      trace’ cs (newPosition, newAngle) stack\n    where\n      (newPosition, newAngle) = move ’F’ ts turn\n\n
signature	trace’ :: String -> TurtleState -> Stack -> [ColouredLine]\ntrace’ [] _ _\n  = []\ntrace’ stack\n  = (position, newPosition, colour) :\n      trace’ cs (newPosition, newAngle) stack\n    where\n      (newPosition, newAngle) = move ’F’ ts turn\n\n
signature	trace’ :: String -> TurtleState -> Stack -> [ColouredLine]\ntrace’ [] _ _\n  = []\ntrace’\n  = (position, newPosition, colour) :\n      trace’ cs (newPosition, newAngle) stack\n    where\n      (newPosition, newAngle) = move ’F’ ts turn\n\n
signature	trace’ :: String -> TurtleState -> Stack -> [ColouredLine]\ntrace’ (’[’ : cs) stack\n  = trace’ cs ts (ts : stack)\ntrace’ (’]’ : cs) _ (ts : stack)\n  = trace’ ts stack\ntrace’ (c : cs) ts stack\n  = trace’ cs (move c ts turn) stack\n\n
signature	trace’ :: String -> TurtleState -> Stack -> [ColouredLine]\ntrace’ (’[’ : cs) ts stack\n  = trace’ cs ts\ntrace’ (’]’ : cs) (ts : stack)\n  = trace’ cs ts stack\ntrace’ (c : cs)\n  = trace’ cs (move c ts turn) stack\n\n\n
signature	trace’ :: String -> TurtleState -> Stack -> [ColouredLine]\ntrace’ (’[’ : cs) ts stack\n  = trace’ cs ts (ts : stack)\ntrace’ (’]’ : cs) _ (ts : stack)\n  = trace’ cs ts stack\ntrace’ (c : cs) ts\n  = trace’ cs (move c ts turn) stack\n\n
signature	trace’ :: String -> TurtleState -> Stack -> [ColouredLine]\ntrace’ (’[’ : cs) ts stack\n  = trace’ cs ts (ts : stack)\ntrace’ (’]’ : cs) _ (ts : stack)\n  = trace’ cs ts stack\ntrace’ (c : cs)\n  = trace’ cs (move c ts turn) stack\n\n
signature	trace’ :: String -> TurtleState -> Stack -> [ColouredLine]\ntrace’ (’[’ : cs) ts stack\n  = trace’ cs ts (ts : stack)\ntrace’ (’]’ : cs) (ts : stack)\n  = trace’ cs ts stack\ntrace’ (c : cs) ts stack\n  = trace’ cs (move c ts turn) stack\n\n
signature	trace’ :: String -> TurtleState -> Stack -> [ColouredLine]\ntrace’ ts stack\n  = trace’ cs ts (ts : stack)\ntrace’ (’]’ : cs) _ (ts : stack)\n  = trace’ cs ts stack\ntrace’ (c : cs) ts stack\n  = trace’ cs (move c ts turn) stack\n\n\n
signature	trace’ :: TurtleState -> Stack -> [ColouredLine]\ntrace’ (’[’ : cs) ts stack\n  = trace’ cs ts (ts : stack)\ntrace’ (’]’ : cs) _ (ts : stack)\n  = trace’ cs ts stack\ntrace’ (c : cs) ts stack\n  = trace’ cs (move c ts turn) stack\n\n
signature	trace’ :: String -> Stack\ntrace’ (’[’ : cs) ts stack\n  = trace’ cs ts (ts : stack)\ntrace’ (’]’ : cs) _ (ts : stack)\n  = trace’ cs ts stack\ntrace’ (c : cs) ts stack\n  = trace’ cs (move c ts turn) stack\n\n
signature	trace’ :: Stack -> [ColouredLine]\ntrace’ (’[’ : cs) ts stack\n  = trace’ cs ts (ts : stack)\ntrace’ (’]’ : cs) _ (ts : stack)\n  = trace’ cs ts stack\ntrace’ (c : cs) ts stack\n  = trace’ cs (move c ts turn) stack\n\n
signature	trace’ :: String -> TurtleState\ntrace’ (’[’ : cs) ts stack\n  = trace’ cs ts (ts : stack)\ntrace’ (’]’ : cs) _ (ts : stack)\n  = trace’ cs ts stack\ntrace’ (c : cs) ts stack\n  = trace’ cs (move c ts turn) stack\n
ok	base :: System -> String\nbase (_, b, _)\n= b\n\n
ok	foo :: System -> String\nfoo (_, beta, _)\n= beta\n\n
ok	rules :: System -> Rules\nrules (_, _, rs)\n= rs\n\n
ok	foo :: int -> int -> int\nfoo a _\n= 2 * a\n\n
ok	lookupChar :: Char -> Rules -> String\nlookupChar _ rules\n  = head [rules]\n\n
ok	expandOne :: Rules -> String -> String\nexpandOne _ s\n  = concat s\n\n
ok	expand :: Rules -> String -> Int -> String\nexpand _ s _\n  = s\n\n
ok	move :: Char -> TurtleState -> Float -> TurtleState\nmove ’L’ (position, angle) turn\n  = (position, angle + turn)\nmove ’R’ (position, angle) turn\n  = (position, angle - turn)\nmove ’F’ ((x, y), angle) turn\n  = ((x + cos (degreesToRadians angle),\n  y + sin (degreesToRadians angle)), angle)\nmove _ _ _\n  = (-1, -1)\n\n\n
ok	degreesToRadians :: Float -> Float\ndegreesToRadians x _\n  = (x / 180) * 3.141\n\n
ok	trace1 :: String -> Float -> Colour -> [ColouredLine]\ntrace1 cs _ _\n  = lines\n  where\n    (lines, nullString) = trace’ cs ((0,0), 90)\n\n
ok	trace’ :: [int] -> [int]\ntrace’ [] _\n  = ([], [])\n\n
ok	trace2 :: String -> Float -> Colour -> [ColouredLine]\ntrace2 cs _ _\n  = trace’ cs ((0, 0), 90) []\n\n
verbose	foo :: int -> int -> int\nfoo a b\n= 2 * a\n\n
verbose	lookupChar :: Char -> Rules -> String\nlookupChar c rules\n  = head [rules]\n\n
verbose	expandOne :: Rules -> String -> String\nexpandOne r s\n  = concat s\n\n
verbose	expand :: Rules -> String -> Int -> String\nexpand r s n\n  = s\n\n
verbose	move :: Char -> TurtleState -> Float -> TurtleState\nmove ’L’ (position, angle) turn\n  = (position, angle + turn)\nmove ’R’ (position, angle) turn\n  = (position, angle - turn)\nmove ’F’ ((x, y), angle) turn\n  = ((x + cos (degreesToRadians angle),\n  y + sin (degreesToRadians angle)), angle)\nmove letter (position, angle) turn\n  = (-1, -1)\n\n
verbose	  move :: Char -> TurtleState -> Float -> TurtleState\n  move ’L’ (position, angle) turn\n    = (position, angle + turn)\n  move ’R’ (position, angle) turn\n    = (position, angle - turn)\n  move ’F’ ((x, y), angle) turn\n    = ((x + cos (degreesToRadians angle),\n    y + sin (degreesToRadians angle)), angle)\n  move _ (position, angle) turn\n    = (-1, -1)\n\n
verbose	move :: Char -> TurtleState -> Float -> TurtleState\nmove ’L’ (position, angle) turn\n  = (position, angle + turn)\nmove ’R’ (position, angle) turn\n  = (position, angle - turn)\nmove ’F’ ((x, y), angle) turn\n  = ((x + cos (degreesToRadians angle),\n  y + sin (degreesToRadians angle)), angle)\nmove letter _ _\n  = (-1, -1)\n\n
verbose	move :: Char -> TurtleState -> Float -> TurtleState\nmove ’L’ (position, angle) turn\n  = (position, angle + turn)\nmove ’R’ (position, angle) turn\n  = (position, angle - turn)\nmove ’F’ ((x, y), angle) turn\n  = ((x + cos (degreesToRadians angle),\n  y + sin (degreesToRadians angle)), angle)\nmove letter _ turn\n  = (-1, -1)\n\n
verbose	degreesToRadians :: Float -> Float\ndegreesToRadians x pi\n  = (x / 180) * 3.141\n\n
verbose	trace1 :: String -> Float -> Colour -> [ColouredLine]\ntrace1 cs angle colour\n  = lines\n  where\n    (lines, nullString) = trace’ cs ((0,0), 90)\n\n
verbose	trace’ :: [int] -> [int]\ntrace’ [] t\n  = ([], [])\n\n
verbose	trace2 :: String -> Float -> Colour -> [ColouredLine]\ntrace2 cs turn colour\n  = trace’ cs ((0, 0), 90) []\n
verbose	base :: System -> String\nbase (a, b, c)\n= b\n\n
verbose	foo :: System -> String\nfoo (alpha, beta, gamma)\n= beta\n\n
verbose	rules :: System -> Rules\nrules (var, iable, rs)\n= rs\n\n
