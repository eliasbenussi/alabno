#!/usr/bin/env python

import sys
import subprocess
import os
import json

# function to exit with an error message and dump the error message in the output
# json
def exit_with_error(msg, output_json_path):
    jsonobj = {
        'score': 0,
        'annotations': [],
        'error': msg
        }
    jsonstr = json.dumps(jsonobj)
    
    print('Error: {}'.format(msg))
    
    if os.path.isfile(output_json_path):
        print('Output json exists.')
    else:
        try:
            output_json_file = open(output_json_path, 'w')
            output_json_file.write(jsonstr)
            output_json_file.close()
        except:
            print('Could not open file {} for writing'.format(output_json_path))
    
    sys.exit(1)

# calculate classpaths
exec_dir = os.path.abspath(os.path.dirname(os.path.abspath(__file__)))
# exec_dir is simple-haskell-marker
jar_path = os.path.abspath(exec_dir + os.sep + 'target' + os.sep + 'simple-haskell-marker-dev0.1-jar-with-dependencies.jar') + ':' + os.path.abspath('{}/samples/'.format(exec_dir))

# read arguments
# 0 scriptname
# 1 input json path
# 2 output json path

if len(sys.argv) != 3:
    print('Usage: ./SimpleHaskellMarker <input.json> <output.json>')
    sys.exit(1)

input_json_path = sys.argv[1]
output_json_path = sys.argv[2]

# read the input json
input_json_file = open(input_json_path, 'r')
input_json_string = input_json_file.read()
input_json_obj = None
try:
    input_json_obj = json.loads(input_json_string)
except:
    exit_with_error('Could not parse input JSON', output_json_path)

try:
    input_directory = input_json_obj['input_directory']
except:
    exit_with_error('Invalid JSON: could not find key input_directory', output_json_path)

print('Read input directory {}'.format(input_directory))

# chdir into the input directory
try:
    os.chdir(input_directory)
except:
    exit_with_error('Error: input directory {} is invalid or non-accessible'.format(input_directory), output_json_path)

# walk the input directory to find haskell files
haskell_file_paths = []

for root, dirs, files in os.walk(input_directory, topdown=False):
    for name in files:
        filename = os.path.relpath(os.path.join(root,name))
        stem, ext = os.path.splitext(filename)
        if ext == '.hs':
            haskell_file_paths.append(filename)

# make subprocess call
# java -cp jar_path alabno.simple_haskell_marker.Main haskell1 haskell2 output_json_path
cmd = [
    'java',
    '-cp',
    jar_path,
    'alabno.simple_haskell_marker.Main'
    ]
cmd = cmd + haskell_file_paths
cmd.append(output_json_path)

code = subprocess.call(cmd, shell=False)
if code != 0:
    exit_with_error('Subprocess returned code: {}'.format(code), output_json_path)

sys.exit(0)